---
title: Dex文件格式
date: 2016-07-23 09:21:53
categories: Dalvik
tags: 
    - Dex
---

# 什么是dex文件

他是Android系统的可执行文件，包含应用程序的全部操作指令以及运行时数据。

由于dalvik是一种针对嵌入式设备而特殊设计的java虚拟机，所以dex文件与标准的class文件在结构设计上有着本质的区别

当java程序编译成class后，还需要使用dx工具将所有的class文件整合到一个dex文件，目的是其中各个类能够共享数据，在一定程度上降低了冗余，同时也是文件结构更加经凑，实验表明，dex文件是传统jar文件大小的50%左右

![](http://i.stack.imgur.com/1kLrB.png)

可以看见：
dex将原来class每个文件都有的共有信息合成一体，这样减少了class的冗余

# 数据结构

|    类型     |        含义         |
| :-------: | :---------------: |
|    u1     |  unit8_t,1字节无符号数  |
|    u2     | unit16_t,2字节无符号数  |
|    u4     | unit32_t,4字节无符号数  |
|    u8     | unit64_t,8字节无符号数  |
|  sleb128  | 有符号LEB128,可变长度1~5 |
|  uleb128  |    无符号LEB128,     |
| uleb128p1 |   无符号LEB128值加1，   |

其中u1~u8很好理解,[不理解的可以参考这里](http://blog.csdn.net/zklth/article/details/7978362)，表示1到8个字节的无符号数，后面三个是dex特有的数据类型，更详细的参考：(深入到源码解析leb128数据类型)[http://i.woblog.cn/2016/07/23/leb128-format/]

# dex文件结构

首先从宏观上来说dex的文件结果很简单，实际上是由多个不同结构的数据体以首尾相接的方式拼接而成。如下图：

|    数据名称    |                解释                |
| :--------: | :------------------------------: |
|   header   |      dex文件头部，记录整个dex文件的相关属性      |
| string_ids |     字符串数据索引，记录了每个字符串在数据区的偏移量     |
|  type_ids  |       类似数据索引，记录了每个类型的字符串索引       |
| proto_ids  | 原型数据索引，记录了方法声明的字符串，返回类型字符串，参数列表  |
| field_ids  |      字段数据索引，记录了所属类，类型以及方法名       |
| method_ids |   类方法索引，记录方法所属类名，方法声明以及方法名等信息    |
| class_defs | 类定义数据索引，记录指定类各类信息，包括接口，超类，类数据偏移量 |
|    data    |         数据区，保存了各个类的真是数据          |
| link_data  |              连接数据区               |


/dalvik/libdex/DexFile.h

定义如下：

```c++
struct DexFile {
    const DexHeader*    pHeader;
    const DexStringId*  pStringIds;
    const DexTypeId*    pTypeIds;
    const DexFieldId*   pFieldIds;
    const DexMethodId*  pMethodIds;
    const DexProtoId*   pProtoIds;
    const DexClassDef*  pClassDefs;
    const DexLink*      pLinkData;
}
```

>注意：其中一些定义的字段是在内存中并没有存到真是的dex文件中


# header

简单记录了dex文件的一些基本信息，以及大致的数据分布。长度固定为0x70,其中每一项信息所占用的内存空间也是固定的，好处是虚拟机在处理dex时不用考虑dex文件的多样性

|      字段名称       | 偏移值  |  长度  |             说明              |
| :-------------: | :--: | :--: | :-------------------------: |
|      magic      | 0x0  |  8   |     魔数字段，值为"dex\n035\0"     |
|    checksum     | 0x8  |  4   |             校验码             |
|    signature    | 0xc  |  20  |           sha-1签名           |
|    file_size    | 0x20 |  4   |          dex文件总长度           |
|   header_size   | 0x24 |  4   | 文件头长度，009版本=0x5c,035版本=0x70 |
|   endian_tag    | 0x28 |  4   |          标示字节顺序的常量          |
|    link_size    | 0x2c |  4   |      链接段的大小，如果为0就是静态链接      |
|    link_off     | 0x30 |  4   |          链接段的开始位置           |
|     map_off     | 0x34 |  4   |           map数据基址           |
| string_ids_size | 0x38 |  4   |         字符串列表中字符串个数         |
| string_ids_off  | 0x3c |  4   |           字符串列表基址           |
|  type_ids_size  | 0x40 |  4   |          类列表里的类型个数          |
|  type_ids_off   | 0x44 |  4   |            类列表基址            |
| proto_ids_size  | 0x48 |  4   |         原型列表里面的原型个数         |
|  proto_ids_off  | 0x4c |  4   |           原型列表基址            |
| field_ids_size  | 0x50 |  4   |            字段个数             |
|  field_ids_off  | 0x54 |  4   |           字段列表基址            |
| method_ids_size | 0x58 |  4   |            方法个数             |
| method_ids_off  | 0x5c |  4   |           方法列表基址            |
| class_defs_size | 0x60 |  4   |          类定义标中类的个数          |
| class_defs_off  | 0x64 |  4   |           类定义列表基址           |
|    data_size    | 0x68 |  4   |        数据段的大小，必须4k对齐        |
|    data_off     | 0x6c |  4   |            数据段基址            |


/dalvik/libdex/DexFile.h

定义如下：

```c++
struct DexHeader {
    u1  magic[8];           /* includes version number */
    u4  checksum;           /* adler32 checksum */
    u1  signature[kSHA1DigestLen]; /* SHA-1 hash */
    u4  fileSize;           /* length of entire file */
    u4  headerSize;         /* offset to start of next section */
    u4  endianTag;
    u4  linkSize;
    u4  linkOff;
    u4  mapOff;
    u4  stringIdsSize;
    u4  stringIdsOff;
    u4  typeIdsSize;
    u4  typeIdsOff;
    u4  protoIdsSize;
    u4  protoIdsOff;
    u4  fieldIdsSize;
    u4  fieldIdsOff;
    u4  methodIdsSize;
    u4  methodIdsOff;
    u4  classDefsSize;
    u4  classDefsOff;
    u4  dataSize;
    u4  dataOff;
};
```

我们可以用：hexdump -c classes.dex查看dex单字节显示的结果，如下：

```shell
0000000   d   e   x  \n   0   3   5  \0 022 217   ?   w   z   ? 031 221
0000010   ?  \f   ?   ?   ?   ?   ?   ? 217 235 200   z   ? 030   I   ?
0000020   ? 003  \0  \0   p  \0  \0  \0   x   V   4 022  \0  \0  \0  \0
0000030  \0  \0  \0  \0   ? 002  \0  \0 024  \0  \0  \0   p  \0  \0  \0
0000040  \b  \0  \0  \0   ?  \0  \0  \0 005  \0  \0  \0   ?  \0  \0  \0
0000050 001  \0  \0  \0 034 001  \0  \0 005  \0  \0  \0   $ 001  \0  \0
0000060 001  \0  \0  \0   L 001  \0  \0   8 002  \0  \0   l 001  \0  \0
0000070   l 001  \0  \0   t 001  \0  \0 201 001  \0  \0 204 001  \0  \0
0000080 222 001  \0  \0 226 001  \0  \0   ? 001  \0  \0   ? 001  \0  \0
0000090   ? 001  \0  \0   ? 001  \0  \0 004 002  \0  \0  \a 002  \0  \0
00000a0  \v 002  \0  \0     002  \0  \0   ( 002  \0  \0   . 002  \0  \0
00000b0   4 002  \0  \0   9 002  \0  \0   B 002  \0  \0   L 002  \0  \0
00000c0 003  \0  \0  \0 005  \0  \0  \0 006  \0  \0  \0  \a  \0  \0  \0
00000d0  \b  \0  \0  \0  \t  \0  \0  \0  \n  \0  \0  \0  \f  \0  \0  \0
00000e0 002  \0  \0  \0 003  \0  \0  \0  \0  \0  \0  \0 004  \0  \0  \0
00000f0 004  \0  \0  \0   x 002  \0  \0  \n  \0  \0  \0 006  \0  \0  \0
0000100  \0  \0  \0  \0  \v  \0  \0  \0 006  \0  \0  \0   x 002  \0  \0
0000110  \v  \0  \0  \0 006  \0  \0  \0   p 002  \0  \0 005  \0 001  \0
0000120 020  \0  \0  \0  \0  \0 004  \0 017  \0  \0  \0 001  \0 003  \0
0000130 021  \0  \0  \0 004  \0 002  \0  \0  \0  \0  \0 004  \0 001  \0
0000140  \r  \0  \0  \0 004  \0  \0  \0 022  \0  \0  \0  \0  \0  \0  \0
0000150 001  \0  \0  \0 002  \0  \0  \0  \0  \0  \0  \0   ?   ?   ?   ?
0000160  \0  \0  \0  \0   ? 002  \0  \0  \0  \0  \0  \0 006   <   i   n
0000170   i   t   >  \0  \v   H   e   l   l   o       W   o   r   l   d
0000180  \0 001   L  \0  \f   L   H   e   l   l   o   W   o   r   l   d
0000190   ;  \0 002   L   L  \0 025   L   j   a   v   a   /   i   o   /
00001a0   P   r   i   n   t   S   t   r   e   a   m   ;  \0 022   L   j
00001b0   a   v   a   /   l   a   n   g   /   O   b   j   e   c   t   ;
00001c0  \0 022   L   j   a   v   a   /   l   a   n   g   /   S   t   r
00001d0   i   n   g   ;  \0 031   L   j   a   v   a   /   l   a   n   g
00001e0   /   S   t   r   i   n   g   B   u   i   l   d   e   r   ;  \0
00001f0 022   L   j   a   v   a   /   l   a   n   g   /   S   y   s   t
0000200   e   m   ;  \0 001   V  \0 002   V   L  \0 023   [   L   j   a
0000210   v   a   /   l   a   n   g   /   S   t   r   i   n   g   ;  \0
0000220 006   a   p   p   e   n   d  \0 004   a   r   g   s  \0 004   m
0000230   a   i   n  \0 003   o   u   t  \0  \a   p   r   i   n   t   l
0000240   n  \0  \b   t   o   S   t   r   i   n   g  \0 016   ?   ? 231
0000250   ? 230   ?   ?   ? 200   ?   ?   ?   ? 211 213   ? 206 231   ?
0000260 232 204   s   m   a   l   i   ?   ? 236   ?   ? 213  \0  \0  \0
0000270 001  \0  \0  \0  \a  \0  \0  \0 001  \0  \0  \0 003  \0  \0  \0
0000280  \0  \0  \0  \0  \0  \0  \0  \0  \0 001 017  \a  \0  \0  \0  \0
0000290  \v  \0 001  \0 002  \0  \0  \0 210 002  \0  \0   (  \0  \0  \0
00002a0   b  \0  \0  \0  \0  \0  \0  \0  \0  \0 022   2 023 003   ?   ?
00002b0 030 004  \0  \0 001  \0  \0  \0  \0  \0 034 005 003  \0 001   &
00002c0   "  \a 004  \0   p 020 002  \0  \a  \0 032  \b 023  \0   n    
00002d0 003  \0 207  \0  \f  \a   n 020 004  \0  \a  \0  \f  \t   n    
00002e0 001  \0 220  \0 032 001 001  \0   n     001  \0 020  \0 016  \0
00002f0  \0  \0 001  \0  \0  \t 220 005 016  \0  \0  \0  \0  \0  \0  \0
0000300 001  \0  \0  \0  \0  \0  \0  \0 001  \0  \0  \0 024  \0  \0  \0
0000310   p  \0  \0  \0 002  \0  \0  \0  \b  \0  \0  \0   ?  \0  \0  \0
0000320 003  \0  \0  \0 005  \0  \0  \0   ?  \0  \0  \0 004  \0  \0  \0
0000330 001  \0  \0  \0 034 001  \0  \0 005  \0  \0  \0 005  \0  \0  \0
0000340   $ 001  \0  \0 006  \0  \0  \0 001  \0  \0  \0   L 001  \0  \0
0000350 002      \0  \0 024  \0  \0  \0   l 001  \0  \0 001 020  \0  \0
0000360 002  \0  \0  \0   p 002  \0  \0 003 020  \0  \0 002  \0  \0  \0
0000370 200 002  \0  \0 003      \0  \0 001  \0  \0  \0 210 002  \0  \0
0000380 001      \0  \0 001  \0  \0  \0 220 002  \0  \0  \0      \0  \0
0000390 001  \0  \0  \0   ? 002  \0  \0  \0 020  \0  \0 001  \0  \0  \0
00003a0   ? 002  \0  \0                                                
00003a4
```

我们还可以用-C显示16进制和ASCII码

hexdump -C classes.dex

```shell
00000000  64 65 78 0a 30 33 35 00  12 8f b1 77 7a e9 19 91  |dex.035....wz...|
00000010  f2 0c ff ce a0 ce aa cd  8f 9d 80 7a ac 18 49 bf  |...........z..I.|
00000020  a4 03 00 00 70 00 00 00  78 56 34 12 00 00 00 00  |....p...xV4.....|
00000030  00 00 00 00 f8 02 00 00  14 00 00 00 70 00 00 00  |............p...|
00000040  08 00 00 00 c0 00 00 00  05 00 00 00 e0 00 00 00  |................|
00000050  01 00 00 00 1c 01 00 00  05 00 00 00 24 01 00 00  |............$...|
00000060  01 00 00 00 4c 01 00 00  38 02 00 00 6c 01 00 00  |....L...8...l...|
00000070  6c 01 00 00 74 01 00 00  81 01 00 00 84 01 00 00  |l...t...........|
00000080  92 01 00 00 96 01 00 00  ad 01 00 00 c1 01 00 00  |................|
00000090  d5 01 00 00 f0 01 00 00  04 02 00 00 07 02 00 00  |................|
000000a0  0b 02 00 00 20 02 00 00  28 02 00 00 2e 02 00 00  |.... ...(.......|
000000b0  34 02 00 00 39 02 00 00  42 02 00 00 4c 02 00 00  |4...9...B...L...|
000000c0  03 00 00 00 05 00 00 00  06 00 00 00 07 00 00 00  |................|
000000d0  08 00 00 00 09 00 00 00  0a 00 00 00 0c 00 00 00  |................|
000000e0  02 00 00 00 03 00 00 00  00 00 00 00 04 00 00 00  |................|
000000f0  04 00 00 00 78 02 00 00  0a 00 00 00 06 00 00 00  |....x...........|
00000100  00 00 00 00 0b 00 00 00  06 00 00 00 78 02 00 00  |............x...|
00000110  0b 00 00 00 06 00 00 00  70 02 00 00 05 00 01 00  |........p.......|
00000120  10 00 00 00 00 00 04 00  0f 00 00 00 01 00 03 00  |................|
00000130  11 00 00 00 04 00 02 00  00 00 00 00 04 00 01 00  |................|
00000140  0d 00 00 00 04 00 00 00  12 00 00 00 00 00 00 00  |................|
00000150  01 00 00 00 02 00 00 00  00 00 00 00 ff ff ff ff  |................|
00000160  00 00 00 00 f0 02 00 00  00 00 00 00 06 3c 69 6e  |.............<in|
00000170  69 74 3e 00 0b 48 65 6c  6c 6f 20 57 6f 72 6c 64  |it>..Hello World|
00000180  00 01 4c 00 0c 4c 48 65  6c 6c 6f 57 6f 72 6c 64  |..L..LHelloWorld|
00000190  3b 00 02 4c 4c 00 15 4c  6a 61 76 61 2f 69 6f 2f  |;..LL..Ljava/io/|
000001a0  50 72 69 6e 74 53 74 72  65 61 6d 3b 00 12 4c 6a  |PrintStream;..Lj|
000001b0  61 76 61 2f 6c 61 6e 67  2f 4f 62 6a 65 63 74 3b  |ava/lang/Object;|
000001c0  00 12 4c 6a 61 76 61 2f  6c 61 6e 67 2f 53 74 72  |..Ljava/lang/Str|
000001d0  69 6e 67 3b 00 19 4c 6a  61 76 61 2f 6c 61 6e 67  |ing;..Ljava/lang|
000001e0  2f 53 74 72 69 6e 67 42  75 69 6c 64 65 72 3b 00  |/StringBuilder;.|
000001f0  12 4c 6a 61 76 61 2f 6c  61 6e 67 2f 53 79 73 74  |.Ljava/lang/Syst|
00000200  65 6d 3b 00 01 56 00 02  56 4c 00 13 5b 4c 6a 61  |em;..V..VL..[Lja|
00000210  76 61 2f 6c 61 6e 67 2f  53 74 72 69 6e 67 3b 00  |va/lang/String;.|
00000220  06 61 70 70 65 6e 64 00  04 61 72 67 73 00 04 6d  |.append..args..m|
00000230  61 69 6e 00 03 6f 75 74  00 07 70 72 69 6e 74 6c  |ain..out..printl|
00000240  6e 00 08 74 6f 53 74 72  69 6e 67 00 0e e8 bf 99  |n..toString.....|
00000250  e6 98 af e4 b8 80 e4 b8  aa e6 89 8b e5 86 99 e7  |................|
00000260  9a 84 73 6d 61 6c 69 e5  ae 9e e4 be 8b 00 00 00  |..smali.........|
00000270  01 00 00 00 07 00 00 00  01 00 00 00 03 00 00 00  |................|
00000280  00 00 00 00 00 00 00 00  00 01 0f 07 00 00 00 00  |................|
00000290  0b 00 01 00 02 00 00 00  88 02 00 00 28 00 00 00  |............(...|
000002a0  62 00 00 00 00 00 00 00  00 00 12 32 13 03 ff ff  |b..........2....|
000002b0  18 04 00 00 01 00 00 00  00 00 1c 05 03 00 01 26  |...............&|
000002c0  22 07 04 00 70 10 02 00  07 00 1a 08 13 00 6e 20  |"...p.........n |
000002d0  03 00 87 00 0c 07 6e 10  04 00 07 00 0c 09 6e 20  |......n.......n |
000002e0  01 00 90 00 1a 01 01 00  6e 20 01 00 10 00 0e 00  |........n ......|
000002f0  00 00 01 00 00 09 90 05  0e 00 00 00 00 00 00 00  |................|
00000300  01 00 00 00 00 00 00 00  01 00 00 00 14 00 00 00  |................|
00000310  70 00 00 00 02 00 00 00  08 00 00 00 c0 00 00 00  |p...............|
00000320  03 00 00 00 05 00 00 00  e0 00 00 00 04 00 00 00  |................|
00000330  01 00 00 00 1c 01 00 00  05 00 00 00 05 00 00 00  |................|
00000340  24 01 00 00 06 00 00 00  01 00 00 00 4c 01 00 00  |$...........L...|
00000350  02 20 00 00 14 00 00 00  6c 01 00 00 01 10 00 00  |. ......l.......|
00000360  02 00 00 00 70 02 00 00  03 10 00 00 02 00 00 00  |....p...........|
00000370  80 02 00 00 03 20 00 00  01 00 00 00 88 02 00 00  |..... ..........|
00000380  01 20 00 00 01 00 00 00  90 02 00 00 00 20 00 00  |. ........... ..|
00000390  01 00 00 00 f0 02 00 00  00 10 00 00 01 00 00 00  |................|
000003a0  f8 02 00 00                                       |....|
000003a4
```

## magic

标识一个有效的dex文件，他的固定值为：64 65 78 0a 30 33 35 00，转换为字符串为dex.035.
在电子取证中也称“文件签名”

## checksum

他是整个头部的校验和。它被用来校验头部是否损坏

## signature

## file_size

记录包括dexHeader在内的整个dex文件大小，用来计算偏移和方便定位某区段(section),他也有诸如唯一的标识dex,因为他是dex文件中计算sha-1区段的一个组成部分

## header_size

存放整个DexHeadeer结构体的长度，它也可用来计算下一个区段在文件中的起始位置，目前值为0x70

## endian_tag

指定dex运行环境的CPU字节序，存放的是一个固定值，所有dex文件都一样的，值为：78 56 34 12,0x12345678,表示默认采用little-endian字节序

## link_size 

## link_off

当多个class文件被编译到一个dex文件是，他们会用到link_size和link_off，通常为0

可以看到上面的，link_off：为00 00 00 00

## map_off

他指定了dexMapList结构的文件偏移量

## string_ids_size

是指string存放区段的大小，用来计算string区段起始位置-相对于dex文件加载基地址的偏移量

string_ids_off存放string区段的实际偏移量，单位字节。他可以帮助编译器和虚拟机直接跳到这个区段，而不必从前读到后，一直读取到该位置。
type,prototype,method,class,data id的大小(size)和偏移量(offset)和string的作用一样

每个字符串都对应一个DexStringId数据结构，大小为4B,同时虚拟机可以通过头文件中的string_ids_size知道当前dex文件中字符串的总数，也就是string_ids区域中DexStringId数据结构的总数，所以虚拟机可以通过简单的乘法运算即可实现对字符串资源的索引,我们举个例子来根据header里面的字符串信息索引字符串，还是以上面的classes.dex文件来分析：

### 根据stringIdsSize找到有多少个DexStringId（也就是有多少个字符串）

0x38：0x14,说明有20个字符串

### 根据stringIdsOff查看DexStringId的偏移量

0x3c：0x70,说明DexStringId的开始位置在0x70

读取4个字节：6c 01 00 00，转为地址为0x16c，这就是第一个字符串的位置
在读取4个字节：74 01 00 00，0x174

分别获取这个两个位置的字符串：

06 3c 69 6e 69 74 3e 00:值为`<init>\0`,其中06表示后面有6个字符(不包括\0)
0b 48 65 6c 6c 6f 20 57 6f 72 6c 64:值为Hello World\0,0b表示有11个字符


我们发现每个字符串是使用“\0”分割的

首先他的开始位置0x70,我们根据stringIdsSize的值得知接下来有20个字符，首先我们计算DexStringId的地址截止到:0x70+0x14(20)*4=0xc0(不包括0xc0)

先获取DexStringId，然后在获取地址位置的值

| DexStringId偏移 | String偏移 | 值                         |
| ------------- | -------- | ------------------------- |
| 0x70          | 0x16c    | <init>                    |
| 74            | 174      | Hello World               |
| 78            | 181      | L                         |
| 7c            | 184      | LHelloWorld;              |
| 80            | 192      | LL                        |
| 84            | 196      | Ljava/io/PrintStream;     |
| 88            | 1ad      | Ljava/lang/Object;        |
| 8c            | 1c1      | Ljava/lang/String;        |
| 90            | 1d5      | Ljava/lang/StringBuilder; |
| 94            | 1f0      | Ljava/lang/System;        |
| 98            | 204      | V                         |
| 9c            | 207      | VL                        |
| a0            | 20b      | [Ljava/lang/String;       |
| a4            | 220      | append                    |
| a8            | 228      | args                      |
| ac            | 22e      | main                      |
| b0            | 234      | out                       |
| b4            | 239      | println                   |
| b8            | 242      | toString                  |
| bc            | 24c      |                           |

上面的字符串并非普通的ASCII字符串，他们是由MUTF-8编码来表示的。

MUTF-8是指modified UTF-8，即修改过的utf-8和普通的utf-8有以下区别：

1. 使用1~3字节编码长度
2. 大于16位

## dex文件结构分析

我们采用前面的classes.dex文件作为演示对象

dalvik虚拟机解析dex文件的内容，最终将其映射成DexMapList数据结构，DexHeader中的mapOff字段指定了DexMapList结构在dex在文件中的偏移，他的申明如下：


/dalvik/libdex/DexFile.h

```c++
struct DexMapList {
    u4  size;               /* 个数 */
    DexMapItem list[1];     /* DexMapItem的结构 */
};
```

其中size字段表示dex接来下有多少个DexMapItem结构

```c++
struct DexMapItem {
    u2 type;              /* kDexType开头的类型 */
    u2 unused;            /*未使用，用于字节对齐 */
    u4 size;              /* 类型的个数 */
    u4 offset;            /* 类型的文件偏移 */
};
```

type字段为一个枚举常量，可以通过类型名称很容易判断他的具体类型：

```c++
enum {
    kDexTypeHeaderItem               = 0x0,
    kDexTypeStringIdItem             = 0x1,
    kDexTypeTypeIdItem               = 0x2,
    kDexTypeProtoIdItem              = 0x3,
    kDexTypeFieldIdItem              = 0x4,
    kDexTypeMethodIdItem             = 0x5,
    kDexTypeClassDefItem             = 0x6,
    kDexTypeMapList                  = 0x0,
    kDexTypeTypeList                 = 0x1,
    kDexTypeAnnotationSetRefList     = 0x2,
    kDexTypeAnnotationSetItem        = 0x3,
    kDexTypeClassDataItem            = 0x0,
    kDexTypeCodeItem                 = 0x1,
    kDexTypeStringDataItem           = 0x2,
    kDexTypeDebugInfoItem            = 0x3,
    kDexTypeAnnotationItem           = 0x4,
    kDexTypeEncodedArrayItem         = 0x5,
    kDexTypeAnnotationsDirectoryItem = 0x6,
};
```

这里我们以上面的clsses.dex来分析，DexHeader结构的mapOff字段为f8 02 00 00，根据小端序，他的值为0x2f8,读取0x290出的双字节值为0e 00（0e）,表示接下来有13个DexMapItem结构








































